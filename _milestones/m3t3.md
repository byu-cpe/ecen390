---
parent: Milestone 3
title: Task 3
nav_order: 3
---
{%- include vars.html -%}

# Circular Buffer, Hit Detector, Shot Counter
{: .no_toc }

## Table of contents
{: .no_toc .text-delta }

1. TOC
{:toc}

-----

## Overview

In this task you will finish implementing the receive path of your
laser-tag system, which includes a circular buffer and a hit detector.
The filter component of the receive path was implemented in Milestone 3,
Task 1. An implementation of the receiver (rx) driver is provided for
you. The receiver driver interacts with the ADC, which digitizes the
amplified signal coming from the photodiode on your analog board.
Additionally, you will implement a shot component that will keep track
of the number of shots remaining. You will test each of these components
with provided test code to verify correct operation. In a later
milestones, you will be guided how to connect these components in a
complete laser-tag system.

### Components

1.  **Circular Buffer:** this buffer stores values digitized by the ADC.
1.  **Receiver Driver:** this driver digitizes an incoming analog signal
    and places the samples in the circular buffer.
1.  **Hit Detector:** this detector takes the current energy for
    each channel coming from the filter component and detects if a hit
    is present.
1.  **Shot Counter:** this counter keeps track of the number of shots
    remaining.

![]({{media}}../m3t1/receive.png)
![]({{media}}shot.png)

### General Requirements

1.  Implement a circular buffer for storing values read from the ADC.
1.  Implement the hit detection algorithm.
1.  Implement a shot counter with reload capability.
1.  When implementing components, follow the descriptions given for
    each function in the header files.
1.  You must follow the [coding standard]({% link docs/coding-standard.md %}).
1.  You must demonstrate the behavior of your components to the TAs using
    the provided test code.

-----

## Resources

  - [Insertion sort](https://en.wikipedia.org/wiki/Insertion_sort)
  - [Selection sort](https://en.wikipedia.org/wiki/Selection_sort)
  - [Median value](http://en.wikipedia.org/wiki/Median)

### Source Code

Note that the following files are provided in your ecen390 project
directory. The test code is used to check the correctness of your code.

  - ltag/main/buffer.h
  - ltag/main/detector.h
  - ltag/main/shot.h
  - ltag/main/main_m3t3.c
  - ltag/main/test/test_buffer.h
  - ltag/main/test/test_buffer.c
  - ltag/main/test/test_detector.h
  - ltag/main/test/test_detector.c
  - ltag/main/test/test_shot.h
  - ltag/main/test/test_shot.c

You are expected to create and implement the following files. See the
provided header files (.h) for a description of each function.

  - ltag/main/buffer.c
  - ltag/main/detector.c
  - ltag/main/shot.c

{: .important }
When implementing each function, pay attention to the function
descriptions in the header files. In fact, save lost points from the
coding checker by copying the comments and function prototypes from the
header files to your .c files to start your code. Also, you are likely
to lose points from the coding checker if you modify the header files!
So, don't modify the provided header files.

-----

## Implementation

### Circular Buffer

#### Specification

  - Only use integer types (uint16\_t, uint32\_t, int16\_t, etc.)
    in the implementation. **DO NOT** use float or double types\!
  - The buffer is cleared of any elements with `buffer_init()`.
  - When adding a value to the buffer, the oldest value is overwritten
    if the buffer is full.
  - When reading a value from the buffer, zero is returned if the
    buffer is empty.
  - The capacity of the buffer in elements is returned with
    `buffer_size()`.
  - The number of elements stored in the buffer is returned with
    `buffer_elements()`.

#### Detail

Implement a circular buffer in buffer.c that is dedicated to storing
incoming **integer** data of type `buffer_data_t`.

A sketch is given below as a starting point for an implementation of
buffer.c. You will need to finish the implementation.

```c
#include "buffer.h"

#define BUFFER_SIZE 16384

typedef struct {
    uint32_t indexIn; // Points to the next open slot.
    uint32_t indexOut; // Points to the next element to be removed.
    uint32_t elementCount; // Number of elements in the buffer.
    buffer_data_t data[BUFFER_SIZE]; // Values are stored here.
} buffer_t;

volatile static buffer_t buf;

// Functions...
```

{: .warning }
Do not implement the buffer component by shifting values. It will be too
slow!

### Hit Detector

#### Specification

<!--   - `detector_init()`: Initializes the detector module. By default, all
    frequencies are considered for hits. The function assumes the filter
    module is initialized previously.
  - `detector_setIgnoredFrequencies(bool freqArray[])`: You pass it a
    preinitialized array of 10 booleans. If freqArray\[0\] is true, for
    example, no hits should be registered for this frequency when you
    run the detector() function.
  - `detector(bool interruptsCurrentlyEnabled)`: This runs the entire
    detector once each time 10 new inputs have been received, including
    the decimating FIR-filter, all 10 IIR-filters, energy computation,
    and the previously-described hit-detection algorithm. `detector()`
    sets a boolean flag to true if a hit was detected. The
    interruptsCurrentlyEnabled flag will be set to true if interrupts
    are enabled and false otherwise.
  - `detector_hitDetected()`: Simply returns the boolean flag that was
    set by `detector()`. Example code provided in runningModes.c calls
    `detector()` and then calls `detector_hitDetected()` to determine if
    you have been hit.
  - `detector_clear()`: This function simply clears the aforementioned
    flag.
  - `detector_getHitCounts()`: This function simply copies the values
    from the detector\_hitArray into the supplied argument. You provide
    an array of size 10 as the only argument. After invoking this
    function, the array will contain the same values as
    detector\_hitArray.
  - `detector_runTest()`: When invoked, this function will test the
    functionality of your detector software. This test function is
    described below. -->

#### Detail

When you invoke `detector_run()`, perform the following steps:

<!-- 1.  Query the ADC buffer to determine how many elements it contains. Use
    `buffer_elements()` for this. Call this amount `elementCount`.
2.  Now, repeat the following steps `elementCount` times.
      - If interrupts are enabled (check to see if the interruptsEnabled
        argument == true), briefly disable interrupts by invoking
        `interrupts_disableArmInts()`. You must disable interrupts
        briefly while you pop an element from the ADC buffer. Otherwise,
        if an interrupt occurs while you are "popping" a value from the
        buffer, the interrupt routine and your `detector()` routine may
        simultaneously access the ADC buffer and may cause `indexIn`,
        `indexOut`, or some other field of the ADC buffer to be
        miscomputed. This kind of problem can be very difficult to track
        down because it is hard to reproduce, so it is best to avoid the
        problem in the first place.
      - Pop a value from the ADC buffer (use `buffer_pop()` for this).
        Place this value in a variable called `rawAdcValue`.
      - If the interruptsEnabled argument was true, re-enable interrupts
        by invoking `interrupts_enableArmInts()`.
      - Scale the integer value contained in `rawAdcValue` to a `double`
        that is between -1.0 and 1.0. Store this value into a variable
        named `scaledAdcValue`. The ADC generates a 12-bit output that
        ranges from 0 to 4095. 0 would map to -1.0. 4095 maps to 1.0.
        Values in between 0 and 4095 map linearly to values between -1.0
        and 1.0. **Note: this is a common source of bugs. Carefully test
        the code that does this mapping.**
      - Invoke `filter_addNewInput(scaledAdcValue)`. This provides a new
        input to the FIR filter.
      - If filter\_addNewInput() has been called 10 times since the last
        invocation of the FIR and IIR filters, run the FIR filter, IIR
        filter and energy computation for all 10 channels. Remember to
        only invoke these filters and energy computations after
        `filter_addNewInput()` has been called 10 times (decimation). If
        you have just run the filters and computed energy, also do the
        following:
          -  if the lockoutTimer is not running, run the hit-detection
            algorithm. If you detect a hit and the frequency with
            maximum energy is not an ignored frequency, do the following:
              - start the lockoutTimer.
              - start the hitLedTimer.
              - increment detector\_hitArray at the index of the
                frequency of the IIR-filter output where you detected
                the hit. Note that detector\_hitArray is a 10-element
                integer array that simply holds the current number of
                hits, for each frequency, that have occurred to this
                point.
              -  set detector\_hitDetectedFlag to true. -->

#### Detecting "Hits"

Having completed the filter component, you have code that
can compute the total energy that passes through each of your IIR-based
bandpass filters. Now what? Here are some considerations.

1.  You could always select the band-pass filter output that contains
    the maximum energy relative to the others. Unfortunately this simple
    scheme won't work because it would always detect a "hit" of some
    sort, even when no one is shooting at you. Due to various noise
    sources, there will always be some energy in at least some of the
    frequencies, even when no one is shooting at you.
2.  You could select the frequency that contains a energy value that is
    above some threshold. This "kind of" works; however, it is difficult
    or impossible to come up with a threshold that works in enough
    situations. For example, let's say you perform some experiments in
    indoor light with the two guns spaced apart by about 10 feet. At
    this distance, you set the threshold so that "hits" are only
    detected when the computed energy is above the threshold. OK so far.
    Now you move the guns so that they are 20-feet apart. Now, when you
    press the trigger, nothing happens because the energy numbers across
    all frequencies are not above the threshold. You can lower the
    threshold to increase sensitivity and detect "hits" at greater
    distances. However, at some point you will begin to detect noise
    (from your amplifier circuitry, from the ambient lighting, etc.) as
    a "hit". Clearly, just comparing the energy in the band-pass filter
    outputs to a **fixed** threshold won't work very well.

#### A Hit-Detection Algorithm

We will use an algorithm that adjusts the threshold based upon the
current energy contained in the outputs from all 10 bandpass filters.

The detection algorithm consists of the following steps:

1.  After running all of the filters and computing the energy for each
    bandpass filter output, sort the energy values in ascending order
    according to their magnitude. Just use an [insertion
    sort](http://en.wikipedia.org/wiki/Insertion_sort) or a [selection
    sort](https://en.wikipedia.org/wiki/Selection_sort) algorithm to do
    the sorting. *Pro Tip: sort a separate array containing
    the indices of the original array.*
2.  Select the [median value](http://en.wikipedia.org/wiki/Median).
    Selecting the median value is simple once you have sorted the energy
    values -- the median value is simply the value "in the middle" of
    the set of sorted values. For our system, we have 10 energy values;
    once they are sorted in ascending order, the median value is either
    the 5th or 6th element according to the sorted order. **Everyone
    should sort values in ascending order and select the 5th value for
    consistency.**
3.  Multiply the median value with a factor to compute a
    threshold. This computed threshold should be high enough to reject
    noise and avoid false "hits" but should be low enough to detect hits
    from a distance of 40 feet or so. You will compute a default threshold
    factor through experimentation in Milestone 4. Why use a threshold
    factor? Because it can adjust for the different sensitivities in
    everyone's analog board.
4.  Find the bandpass filter that contains the maximum energy (this is
    easy to do once you have sorted the values). If the maximum energy
    exceeds the threshold (median_value \* threshold_factor), you have
    detected a hit.

You will implement this hit-detection algorithm in this task.

#### Hit-Detection Algorithm Example

Here is an example of the hit-detection algorithm in operation. Assume
the threshold factor = 5. Let's say that we retrieve the current energy
values for all 10 frequencies using the previously-implemented function:
`filter_getEnergyArray()`. The retrieved energy values for the 10
frequencies for this example are:

  - energy\[0\]: 150
  - energy\[1\]: 20
  - energy\[2\]: 40
  - energy\[3\]: 10
  - energy\[4\]: 15
  - energy\[5\]: 30
  - energy\[6\]: 35
  - energy\[7\]: 15
  - energy\[8\]: 25
  - energy\[9\]: 80

After sorting in ascending order, we get the following:

  - energy\[3\]: 10 (\#1)
  - energy\[7\]: 15 (\#2)
  - energy\[4\]: 15 (\#3)
  - energy\[1\]: 20 (\#4)
  - energy\[8\]: 25 (\#5)
  - energy\[5\]: 30 (\#6)
  - energy\[6\]: 35 (\#7)
  - energy\[2\]: 40 (\#8)
  - energy\[9\]: 80 (\#9)
  - energy\[0\]: 150 (\#10)

The median value (sorted element \#5) is 25 from the bandpass filter
for frequency 8. For this example, that would mean that you would only
detect hits for values that are over the threshold value of
25 (median value) \* 5 (threshold factor) = 125. The band-pass filter for
frequency 0 has the maximum energy value (150) which is greater than 125
so we would detect a hit.

Let's run the detector again with another set of data. After sorting,
the energy values from the band-pass filter outputs are as follows:

  - energy\[2\]: 10 (\#1)
  - energy\[1\]: 25 (\#2)
  - energy\[4\]: 30 (\#3)
  - energy\[7\]: 30 (\#4)
  - energy\[8\]: 45 (\#5)
  - energy\[6\]: 50 (\#6)
  - energy\[5\]: 55 (\#7)
  - energy\[3\]: 65 (\#8)
  - energy\[9\]: 70 (\#9)
  - energy\[0\]: 150 (\#10)

Our median value (element \#5 in sorted order) = 45. We compute the new
threshold by multiplying 45 \* 5 (threshold factor) = 225. Our maximum
energy value (150) is less than our computed threshold (225) so no hit is
detected. The reason no hit is detected is because the maximum energy is
not sufficiently greater than the energy contained in the outputs of the
other bandpass filters.

{: .note }
These numbers are provided solely for example. The actual
numbers you will encounter in your system will be quite different.

<!-- #### Determining the threshold factor

A wide range of threshold factors will work when using the loop-back
circuitry on the board for this task. I have successfully tested systems
with fudge factors as high as 10,000. However, such high values won't
work when using the analog board. For this task, you can probably just
select a value between 200 and 1,000. If you note false detections,
raise the threshold factor until they are eliminated.

The general idea behind this detection approach is that the threshold
*tracks* the current background noise to some degree. Thus if the
frequency channels all have energy values that are a little high, the
computed threshold also tracks higher. Vice versa, if the frequency
channels all have energy values that are lower, the computed threshold
also tracks lower. In practice this detection strategy has worked quite
well, often achieving distances of 100'. -->

### Shot Counter

#### Specification

#### Detail

-----

## Test Code

To pass off this task, you must run your code with the provided test
code. The test code calls functions in buffer.c, detector.c and in
shot.c. The test results are printed to the terminal window.

Before building the test code, first set the MILESTONE variable in
ltag/main/CMakeLists.txt to "m3t3".

```cmake
set(MILESTONE "m3t3")
```

Then, to build and run the tests, type the following:

```sh
idf.py build
idf.py flash monitor
```

The test results printed to a terminal window on the host computer will
look like this if everything passes:

```
******** test_buffer() ********
initialization test
half-fill and drain test
fill and drain test
push, pop, push, pop test
over-fill and drain test
push and over-drain test
******** test_buffer() Done ********

******** test_detector() ********
detector_checkHit() phase 1 test
detector_checkHit() phase 2 test
detector_checkHit() phase 3 test
detector_checkHit() phase 4 test
detector_checkHit() phase 5 test
detector_run() test, threshold:2048.0
hit_ch:0 energy:3.53e+01 pulse:21 ms det:14 ms
hit_ch:1 energy:2.82e+01 pulse:19 ms det:12 ms
hit_ch:2 energy:2.44e+01 pulse:19 ms det:12 ms
hit_ch:3 energy:6.68e+01 pulse:25 ms det:16 ms
hit_ch:4 energy:9.09e+01 pulse:28 ms det:18 ms
hit_ch:5 energy:1.62e+01 pulse:17 ms det:11 ms
hit_ch:6 energy:6.70e+01 pulse:25 ms det:16 ms
hit_ch:7 energy:1.18e+02 pulse:30 ms det:20 ms
hit_ch:8 energy:1.51e+02 pulse:34 ms det:22 ms
hit_ch:9 energy:6.98e+00 pulse:14 ms det: 9 ms
******** test_detector() Done ********

******** test_shot() ********
shot_init() test
shot_decrement() test
shot_timer_start() _stop() test
shot_register_reload() and timer test
shot canceled timer test
******** test_shot() Done ********
```

-----

## Pass Off and Code Submission

  - You will show the TAs how your code behaves when running the
    provided test code. The test results will be displayed in a terminal
    window on the host computer. Nothing is displayed on the laser-tag
    unit LCD.
  - You will submit your source code by doing the following: 
    1.  From the top-level directory (e.g., ecen390), run
        `./check_and_zip.py m3t3`.
    2.  The resulting .zip file will be in the top-level directory.
        Submit that to Learning Suite.
    3.  Submit only one .zip file per group. Both group members will
        receive credit.
